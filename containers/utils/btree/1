#ifndef MAP_HPP
# define MAP_HPP

# include "btree.hpp"
# include "bidirectional_iterator.hpp"
# include "pair.hpp"
# include "../iterator_traits.hpp"
# include <cstddef>
# include <limits.h>
# include <stdexcept>
# include <memory>

namespace ft
{
		template <class Key>
	struct less : std::binary_function <Key,Key,bool>
	{
		bool operator() (const Key & x, const Key & y) const
		{
				return (x < y);
		}
	};
		template < class Key, class T, class Compare = less<Key>, class Alloc = std::allocator<pair<const Key,T> > >
	class map
	{
		typedef  Key									key_type;
		typedef  T										mapped_type;
		typedef  ft::pair<const key_type,mapped_type>	value_type;
		typedef  Compare								key_compare;

		class value_compare
		{
			friend class map<key_type, mapped_type, key_compare, Alloc>;

			protected:
				Compare comp;
				value_compare (Compare c) : comp(c) {}

			public:
				bool operator() (const value_type& x, const value_type& y) const
				{ return (comp(x.first, y.first)); }
		};

		typedef	Alloc																allocator_type;
		typedef typename allocator_type::reference									reference;
		typedef typename allocator_type::const_reference							const_reference;
		typedef typename allocator_type::pointer									pointer;
		typedef typename allocator_type::const_pointer								const_pointer;
		typedef typename ft::bidirectional_iterator<value_type, key_compare>		iterator;
		typedef typename ft::bidirectional_iterator<const value_type, key_compare>	const_iterator;
		typedef typename ft::reverse_iterator<iterator>								reverse_iterator;
		typedef typename ft::reverse_iterator<const_iterator>						const_reverse_iterator;


	};
}

#endif
